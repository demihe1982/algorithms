#算法之旅
## 概述
###什么是算法
* 在数学领域里，算法是用于解决某一类问题的公司和思想。
* 在计算机领域里，它的本质是一系列程序指令，用于解决特定的运算和逻辑的问题。
#### 衡量算法好坏的重要两个标准
* 时间复杂度
* 空间复杂度
#### 算法的应用领域
* 运算
* 查找
* 排序
* 最优决策
#### 什么是数据结构
数据结构是算法的基石，是数据的组织、管理和存储的格式，其使用目的是为了高效地访问和修改数据。
数据结构的组成方式
1. 线性结构
 <br> 是最简单的数据结构，包括数组、链表，以及衍生出来的栈、队列、哈希表。
2. 树

是相对复杂的数据结构，比较有代表性的是二叉树，由它衍生出了二叉堆之类的数据结构。
3. 图
 
  是更为复杂的数据结构，在图中会呈现出多对多的关联关系。
4. 其他数据结构
 
 由基础数据结构演变而来的特殊数据结构，比如跳表、哈希链表和位图等。

### 时间复杂度
#### 影响程序好坏的重要因素
* 运行时间长
* 占用空间大
#### 基础操作执行次数
 最常见的4中执行方式
* 执行次数的线性，T(n) = 3n 
  - 一层for循环
* 执行次数是用对数计算，T(n) = 5logn
* 执行次数是常量，T(n) = 3
* 多项式计算，T(n) = 0.5n^2 *+ 0.5n
#### 渐进时间复杂度
大O法表示
* 如果运行时间是常数量级，则用常数1表示， 比如： T(n) = 2 ，则记 O(1)
* 只保留时间函数的最高阶项,比如，T(n) = 0.5n^2 *+ 0.5n ,记O(n^2) 
* 如果最高阶项存在，则省去最高阶项前面的系数
### 空间复杂度
算法运行过程中，临时占用的内存空间，用于存储中间数据，常见的空间复杂度的情形
* 常量空间，例如 int i = 10
* 线性空间，例如 int[] arry = new int[10]
* 二维空间，例如 int[][] bary = new int[1][2]
* 递归空间，用来存储方法调用栈，包括出栈和进栈两个行为

## 数据结构基础
### 什么是数组
是有限个相同类型的变量所组成的有序集合。数组适合用于读操作多，写操作少的前景。
- 在内存中顺序存储
- 实现逻辑上的顺序表
#### 数组操作
1. 读取元素，根据下标读取元素的方式叫随机读取，时间复杂度O(1)
2. 更新元素，直接利用数组下标，就可以把新值赋给该元素，时间复杂度O(1)
3. 插入元素
 - 尾部插入
  - 直接把插入的元素放到数组尾部空闲的位置，同更新元素的操作，时间复杂度O(1)
- 中间插入
  - 将插入位置和其后面的位置进行移动，腾出位置，再把插入元素放到对应的数组位置上，时间复杂度为O(n)
- 超范围插入
  - 数组的扩容，创建一个新数组，长度为旧数组的2倍，再把旧数组中的元素题统统复制过去，实现数组的扩容，时间复杂度O(n)
4. 删除元素
<br/> 与插入元素操作相反，如果删除的元素位于数组中间，其后面的元素需要向前挪动1位，时间复杂度为O(n)

### 什么是链表
链表是一种物理上非连续、非顺序的数据结构，由若干节点（Node）组成
* 单向链表的每一个节点又包含两部分，一部分存放数据的变量data,另外一部分是指向下一个节点的指针next
 ```
    private static class Node{
        int data,
        Node next
    }
```
链表的第一个节点称为头节点，最后一个节点被称为尾节点，尾节点的next指向空。
* 双向链表比单向链表复杂，它的每个节点除了包括data和next指针，还拥有指向前置节点的prev指针
 ```
  private static clas Node{
    int data,
    Node prev,
    Node next
  }
 
 ```
 * 随机存储 
    * 数组在内存中的存储方式是顺序存储，那么链表在内存中的存储方式则是随机存储。
    * 链表采用见缝插针的方式，每个节点分布在内存的不同位置，通过next指针关联起来。
    * 灵活有效的利用零散的碎片空间
    
### 链表的基本操作
1.查找节点

查找元素时，链表不能像数组那样可以通过下标快速定位，只能从头节点开始向后一个一个节点逐一查找。链表中的数据只能按顺序进行访问，最坏的时间复杂度是O(n)。

2.更新节点

如果不考虑查找节点的过程，链表的更新过程像数组那样简单，直接把旧值换成新数据即可。

3.插入节点
   * 尾部插入，把最后一个节点的next指向新插入的节点
   * 头部插入
      1. 新节点的next指针指向原先的头节点
      2. 把新节点变为链表的头节点
   * 中间插入
      1. 新节点的next指针，指向插入位置的节点
      2. 插入位置前置节点的next指针，指向新的节点
      
只要空间允许，能够插入链表的元素是无限的，不需要考虑扩容

4.删除元素

* 尾部删除，把倒数第2个节点的next指针指向空
* 头部删除，把链表头节点设为原先头节点的next指针即可
* 中间删除，把要删除节点的前置节点的next指针，指向要删除的下一个节点

不考虑查找的过程，插入和删除操作，时间复杂度为O(1)

数组 VS 链表

|  | 查找 | 更新 | 插入 | 删除 |
| ---| ---| --- | --- | --- |
|数组|O(1)|O(1)|O(n)|O(n)|
|链表|O(n)|O(1)|O(1)|O(1)|

### 栈和队列
#### 物理结构和逻辑结构
* 物理结构，内存中实实在在的存储结构，例如，数组和链表
   * 顺序存储，如数组
   * 链式存储，链表
* 逻辑结构，抽象概念，它依赖物理结构而存在
  * 线性结构
      - 基于顺序存储的数组结构
      - 顺序表、栈、队列
  * 非线性结构
      - 基于随机存储的链式结构
      - 树、图
#### 栈
栈是一种线性数据结构，**先进后出 FILO**，最先进入的元素存放的位置叫做**栈底** ，最后进入的元素存放的位置叫做**栈顶** 。

1.入栈

把新元素放入栈中，只允许从栈顶放入元素，新元素的位置将成为新的栈顶

2.出栈

把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将成为新的栈顶

#### 队列
队列是一种线性数据结构，先入先出 FIFO，队列的出口端叫队头，队列的入口端叫作对尾,可用数组或者链表实现

1.入队

把新元素放入对列中，只允许在队尾的位置放入元素，新元素的下一个位置将成为新的队尾

2.出队

把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。

#### 栈和队列的应用
* 栈的应用，网页导航条
* 队列应用，网络爬虫
* 双端队列，结合栈和队列的特点
* 优先队列，基于二叉树实现的，按优先级排序优先出队

#### 散列表
散列表也叫哈希表（hash table), 提供了鍵和值的映射关系，时间复杂度为O(1)

哈希表本质是一个数组

Java中的每个对象都有一个hashcode,hashcode都是整型变量，可按照数组的长度取模运算，可对于到数组的下标。Java中的哈希函数是通过位运算的方式优化性能。通过哈希函数可以把字符串或其他类型的Key，转换为数组的下标index。

1.写操作
* 通过哈希函数，把Key转换为数组的下标
* 如果下标对应的位置没有元素，那么就把Entry填充到数组的下标，

但是数组是有限的，写入的数据过多，哈希函数获得的下标可能相同，这就造成哈希冲突

解决哈希冲突的方法
* 开发寻址法，下标被占就寻找下一个空档位置，比如 ThreadLocal
* 链式法，比如 HashMap， HashMap数组中的每一个元素不仅是一个Entry对象，还是一个链表的头节点。

2.读操作
* 通过哈希函数，把Key转换为数组的下标
* 找到数组下标所对应的元素，如果这个元素的Key相等，那么就找到了，否则需顺着链表慢慢查找，看能否找到与Key相匹配的节点。

3.扩容

相关的因素
* Capacity
* LoadFactor ,默认值0.75

衡量HashMap需要进行扩容的条件，HashMap.size = Capacity * LoadFactor

扩容步骤

1.扩容，创建一个新的Entry空数组，长度为原来的2倍
2.重新Hash，遍历原Entry数组，把所有的Entry重新Hash到新的数组中。为提升插入和查找的效率，Jdk8把Entry的链表转换为红黑树。

## 树








##相关书籍
### 漫画算法
### 算法 Algorithms 第四版
